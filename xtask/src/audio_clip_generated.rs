use std::error::Error;
use std::fs;
use std::path::Path;

const GENERATED_CONTENTS: &str = r#"// @generated by `cargo check-all`. Do not edit by hand.
//! Module containing [`PcmClipGenerated`], the sample module generated by
//! the [`pcm_clip!`](macro@crate::audio_player::pcm_clip) macro.
//!
//! Auto-generated.

#[cfg(all(not(doc), not(feature = "host")))]
use crate::audio_player::pcm_clip;

#[cfg(all(not(doc), not(feature = "host")))]
pcm_clip! {
    pub PcmClipGenerated {
        source_sample_rate_hz: crate::audio_player::VOICE_22050_HZ,
        file: "../../examples/data/audio/nasa_22k.s16",
        format: crate::audio_player::AudioFormat::S16le,
    }
}

#[cfg(doc)]
#[allow(non_snake_case)]
/// Sample module generated by the [`pcm_clip!`](macro@crate::audio_player::pcm_clip)
/// macro, showing the generated items.
///
/// This page serves as the reference for what a generated audio clip namespace
/// provides. For first-time readers, start with the
/// [`audio_player`](mod@crate::audio_player) module documentation, then return
/// here for the generated
/// `pcm_clip()`/`pcm_clip_from(...)`/`adpcm_clip()` items.
///
/// The generated items are in a module (not a struct type) because stable Rust
/// does not support inherent associated types on structs.
///
/// Auto-generated.
pub mod PcmClipGenerated {
    use crate::audio_player::{__pcm_clip_from_samples, AdpcmClipBuf, PcmClipBuf, VOICE_22050_HZ, adpcm_data_len_for_pcm_samples};

    /// Sample rate in hertz for this generated clip.
    ///
    /// See the [audio_player module documentation](mod@crate::audio_player) for usage examples.
    pub const SAMPLE_RATE_HZ: u32 = VOICE_22050_HZ;

    /// Number of i16 PCM samples in this generated clip.
    ///
    /// See the [audio_player module documentation](mod@crate::audio_player) for usage examples.
    pub const PCM_SAMPLE_COUNT: usize = 92_160;

    /// Byte length of ADPCM data for this clip.
    ///
    /// See the [audio_player module documentation](mod@crate::audio_player) for usage examples.
    pub const ADPCM_DATA_LEN: usize = adpcm_data_len_for_pcm_samples(PCM_SAMPLE_COUNT);

    /// Returns the duration-preserving destination sample count for a new sample rate.
    ///
    /// See the [audio_player module documentation](mod@crate::audio_player) for usage examples.
    #[must_use]
    pub const fn resampled_sample_count(destination_sample_rate_hz: u32) -> usize {
        crate::audio_player::resampled_sample_count(
            PCM_SAMPLE_COUNT,
            SAMPLE_RATE_HZ,
            destination_sample_rate_hz,
        )
    }

    /// `const` function that returns the generated audio clip.
    ///
    /// See the [audio_player module documentation](mod@crate::audio_player) for usage examples.
    #[must_use]
    pub const fn pcm_clip() -> PcmClipBuf<SAMPLE_RATE_HZ, PCM_SAMPLE_COUNT> {
        __pcm_clip_from_samples([0; PCM_SAMPLE_COUNT])
    }

    /// `const` function that returns the generated audio clip encoded as ADPCM
    /// with 256-byte blocks.
    ///
    /// See the [audio_player module documentation](mod@crate::audio_player) for usage examples.
    #[must_use]
    pub const fn adpcm_clip() -> AdpcmClipBuf<SAMPLE_RATE_HZ, ADPCM_DATA_LEN> {
        pcm_clip().with_adpcm::<ADPCM_DATA_LEN>()
    }

    /// `const` function that PCM-decodes a provided ADPCM clip.
    ///
    /// See the [audio_player module documentation](mod@crate::audio_player) for usage examples.
    #[must_use]
    pub const fn pcm_clip_from(
        adpcm_clip: AdpcmClipBuf<SAMPLE_RATE_HZ, ADPCM_DATA_LEN>,
    ) -> PcmClipBuf<SAMPLE_RATE_HZ, PCM_SAMPLE_COUNT> {
        adpcm_clip.with_pcm::<PCM_SAMPLE_COUNT>()
    }

}
"#;

pub fn generate_audio_clip_generated(workspace_root: &Path) -> Result<(), Box<dyn Error>> {
    let output_path = workspace_root.join("src/audio_player/audio_clip_generated.rs");
    write_if_changed(&output_path, GENERATED_CONTENTS)?;
    Ok(())
}

fn write_if_changed(path: &Path, contents: &str) -> Result<(), Box<dyn Error>> {
    match fs::read_to_string(path) {
        Ok(existing) if existing == contents => Ok(()),
        _ => {
            fs::write(path, contents)?;
            Ok(())
        }
    }
}
