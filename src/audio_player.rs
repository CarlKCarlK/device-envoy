//todo0 search and avoid almost every use of "PCM"
//todo0 where is the example
//todo0 tell standard wiring for i2s
//! A device abstraction for playing and looping audio clips on I2S audio hardware.
//!
//! This page provides the primary documentation for generated audio player
//! types and clip utilities.
//!
//! **See also:**
//!
//! - [`audio_player!`] - Macro to generate an audio player struct type
//!   (includes syntax details). See [`AudioPlayerGenerated`] for a sample of a
//!   generated type.
//! - [`AudioPlayerGenerated`] - Sample struct type showing methods and
//!   associated constants generated by [`audio_player!`].
//! - [`AudioClip`] - A const-friendly audio clip; clips of different lengths can be sequenced together.
//!
//! # Example: Play "Mary Had a Little Lamb" (Phrase) Once
//!
//! This example plays the opening phrase (`E D C D E E E`) and then stops.
//!
//! ```rust,no_run
//! # #![no_std]
//! # #![no_main]
//! # use panic_probe as _;
//! # use core::convert::Infallible;
//! # use core::result::Result::Ok;
//! use device_envoy::{Result, audio_player::{AtEnd, Volume, audio_player, samples_ms}};
//!
//! audio_player! {
//!     AudioPlayer8 {
//!         din_pin: PIN_8,
//!         bclk_pin: PIN_9,
//!         lrc_pin: PIN_10,
//!         max_volume: Volume::percent(50),
//!     }
//! }
//!
//! # #[embassy_executor::main]
//! # async fn main(spawner: embassy_executor::Spawner) -> ! {
//! #     let err = example(spawner).await.unwrap_err();
//! #     core::panic!("{err}");
//! # }
//! async fn example(spawner: embassy_executor::Spawner) -> Result<Infallible> {
//!     static REST_MS: samples_ms! { AudioPlayer8, 80 } = AudioPlayer8::silence();
//!     static NOTE_E4: samples_ms! { AudioPlayer8, 220 } = AudioPlayer8::tone(330);
//!     static NOTE_D4: samples_ms! { AudioPlayer8, 220 } = AudioPlayer8::tone(294);
//!     static NOTE_C4: samples_ms! { AudioPlayer8, 220 } = AudioPlayer8::tone(262);
//!
//!     let p = embassy_rp::init(Default::default());
//!     let audio_player8 = AudioPlayer8::new(p.PIN_8, p.PIN_9, p.PIN_10, p.PIO1, p.DMA_CH0, spawner)?;
//!
//!     audio_player8.play(
//!         [
//!             &NOTE_E4, &REST_MS,
//!             &NOTE_D4, &REST_MS,
//!             &NOTE_C4, &REST_MS,
//!             &NOTE_D4, &REST_MS,
//!             &NOTE_E4, &REST_MS,
//!             &NOTE_E4, &REST_MS,
//!             &NOTE_E4,
//!         ],
//!         AtEnd::Stop,
//!     );
//!
//!     core::future::pending().await // run forever
//! }
//! ```
//!
//! # Example: Event Cues
//!
//! This example plays short one-shot clips for event cues (similar to
//! `clock_audio.rs` notifications).
//!
//! ```rust,no_run
//! # #![no_std]
//! # #![no_main]
//! # use panic_probe as _;
//! # use core::convert::Infallible;
//! # use core::result::Result::Ok;
//! use device_envoy::{Result, audio_player::{AtEnd, Gain, Volume, audio_player, samples_ms}};
//!
//! audio_player! {
//!     AudioPlayer10 {
//!         din_pin: PIN_8,
//!         bclk_pin: PIN_9,
//!         lrc_pin: PIN_10,
//!         pio: PIO1,
//!         dma: DMA_CH1,
//!         max_volume: Volume::percent(10),
//!     }
//! }
//!
//! # #[embassy_executor::main]
//! # async fn main(spawner: embassy_executor::Spawner) -> ! {
//! #     let err = example(spawner).await.unwrap_err();
//! #     core::panic!("{err}");
//! # }
//! async fn example(spawner: embassy_executor::Spawner) -> Result<Infallible> {
//!     static WIFI_CONNECTED_TONE: samples_ms! { AudioPlayer10, 140 } =
//!         AudioPlayer10::tone(880).with_gain(Gain::percent(20));
//!     static TICK_TONE: samples_ms! { AudioPlayer10, 40 } =
//!         AudioPlayer10::tone(523).with_gain(Gain::percent(12));
//!     static SILENCE_40MS: samples_ms! { AudioPlayer10, 40 } = AudioPlayer10::silence();
//!
//!     let p = embassy_rp::init(Default::default());
//!     let audio_player10 = AudioPlayer10::new(p.PIN_8, p.PIN_9, p.PIN_10, p.PIO1, p.DMA_CH1, spawner)?;
//!
//!     audio_player10.play(
//!         [&WIFI_CONNECTED_TONE, &SILENCE_40MS, &WIFI_CONNECTED_TONE],
//!         AtEnd::Stop,
//!     );
//!     audio_player10.play([&TICK_TONE], AtEnd::Stop);
//!
//!     core::future::pending().await // run forever
//! }
//! ```
//TODO0 Review this code

pub mod audio_player_generated;
pub use audio_player_generated::AudioPlayerGenerated;

use core::ops::ControlFlow;
use core::sync::atomic::{AtomicI32, Ordering};

use embassy_rp::Peri;
use embassy_rp::dma::Channel;
use embassy_rp::gpio::Pin;
use embassy_rp::pio::{Instance, Pio, PioPin};
use embassy_rp::pio_programs::i2s::{PioI2sOut, PioI2sOutProgram};
use embassy_sync::{blocking_mutex::raw::CriticalSectionRawMutex, signal::Signal};
use heapless::Vec;

/// Audio sample rate used by `AudioPlayer` playback.
pub const SAMPLE_RATE_HZ: u32 = 22_050;
const BIT_DEPTH_BITS: u32 = 16;
const SAMPLE_BUFFER_LEN: usize = 256;
/// Maximum linear volume scale value.
pub const MAX_VOLUME: i16 = i16::MAX;
const I16_ABS_MAX_I64: i64 = -(i16::MIN as i64);

/// Playback loudness control used by player-level APIs.
///
/// `Volume` is a value object, not device state.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Volume(i16);

impl Volume {
    /// Silence.
    pub const MUTE: Self = Self(0);

    /// Maximum playback volume.
    pub const MAX: Self = Self(MAX_VOLUME);

    /// Creates a volume from a percentage of full scale.
    ///
    /// Values above `100` are clamped to `100`.
    #[must_use]
    pub const fn percent(percent: u8) -> Self {
        let percent = if percent > 100 { 100 } else { percent };
        let value_i32 = (percent as i32 * MAX_VOLUME as i32) / 100;
        Self(value_i32 as i16)
    }

    /// Creates a humorous "goes to 11" demo volume scale.
    ///
    /// `0..=11` maps to `0..=100%` using a perceptual curve
    /// (roughly logarithmic, but not mathematically exact).
    ///
    /// Values above `11` clamp to `11`.
    #[must_use]
    pub const fn spinal_tap(spinal_tap: u8) -> Self {
        let spinal_tap = if spinal_tap > 11 { 11 } else { spinal_tap };
        let percent = match spinal_tap {
            0 => 0,
            1 => 1,
            2 => 3,
            3 => 6,
            4 => 13,
            5 => 25,
            6 => 35,
            7 => 50,
            8 => 71,
            9 => 89,
            10 => 100,
            11 => 100,
            _ => 100,
        };
        Self::percent(percent)
    }

    #[must_use]
    const fn to_i16(self) -> i16 {
        self.0
    }

    #[must_use]
    const fn from_i16(value_i16: i16) -> Self {
        Self(value_i16)
    }
}

/// Signal-domain gain used for clip transforms.
///
/// `Gain` is for multiplying PCM samples and is separate from player `Volume`.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct Gain(i32);

impl Gain {
    /// Silence.
    pub const MUTE: Self = Self(0);

    /// Unity gain (no change).
    pub const UNITY: Self = Self(MAX_VOLUME as i32);

    /// Creates a gain from percentage.
    ///
    /// `100` is unity gain. Values above `100` boost the signal.
    #[must_use]
    pub const fn percent(percent: u16) -> Self {
        let value_i32 = (percent as i32 * MAX_VOLUME as i32) / 100;
        Self(value_i32)
    }

    /// Creates gain from dB with a bounded boost range.
    ///
    /// Values above `+12 dB` clamp to `+12 dB`.
    /// Values below `-96 dB` clamp to `-96 dB`.
    #[must_use]
    pub const fn db(db: i8) -> Self {
        const DB_UPPER_LIMIT: i8 = 12;
        const DB_LOWER_LIMIT: i8 = -96;
        let db = if db > DB_UPPER_LIMIT {
            DB_UPPER_LIMIT
        } else if db < DB_LOWER_LIMIT {
            DB_LOWER_LIMIT
        } else {
            db
        };

        if db == 0 {
            return Self::UNITY;
        }

        // Fixed-point multipliers for 10^(+/-1/20) (approximately +/-1 dB in amplitude).
        const DB_STEP_DOWN_Q15: i32 = 29_205;
        const DB_STEP_UP_Q15: i32 = 36_781;
        const ONE_Q15: i32 = 32_768;
        const ROUND_Q15: i32 = 16_384;
        let step_q15_i32 = if db > 0 {
            DB_STEP_UP_Q15
        } else {
            DB_STEP_DOWN_Q15
        };
        let db_steps_u8 = if db > 0 { db as u8 } else { (-db) as u8 };
        let mut scale_q15_i32 = ONE_Q15;
        let mut step_index = 0_u8;
        while step_index < db_steps_u8 {
            scale_q15_i32 = (scale_q15_i32 * step_q15_i32 + ROUND_Q15) / ONE_Q15;
            step_index += 1;
        }

        let gain_i64 =
            (MAX_VOLUME as i64 * scale_q15_i32 as i64 + ROUND_Q15 as i64) / ONE_Q15 as i64;
        let gain_i32 = if gain_i64 > i32::MAX as i64 {
            i32::MAX
        } else {
            gain_i64 as i32
        };
        Self(gain_i32)
    }

    #[must_use]
    const fn linear(self) -> i32 {
        self.0
    }
}

/// Returns how many samples are needed for a duration in milliseconds.
///
/// Use this in const contexts to size static audio arrays.
#[must_use]
pub const fn samples_for_duration_ms(duration_ms: u32, sample_rate_hz: u32) -> usize {
    assert!(sample_rate_hz > 0, "sample_rate_hz must be > 0");
    ((duration_ms as u64 * sample_rate_hz as u64) / 1_000) as usize
}

#[inline]
const fn sine_sample_from_phase(phase_u32: u32) -> i16 {
    let half_cycle_u64 = 1_u64 << 31;
    let one_q31_u64 = 1_u64 << 31;
    let phase_u64 = phase_u32 as u64;
    let (half_phase_u64, sign_i64) = if phase_u64 < half_cycle_u64 {
        (phase_u64, 1_i64)
    } else {
        (phase_u64 - half_cycle_u64, -1_i64)
    };

    // Bhaskara approximation on a normalized half-cycle:
    // sin(pi * t) ~= 16 t (1 - t) / (5 - 4 t (1 - t)), for t in [0, 1].
    let product_q31_u64 = (half_phase_u64 * (one_q31_u64 - half_phase_u64)) >> 31;
    let denominator_q31_u64 = 5 * one_q31_u64 - 4 * product_q31_u64;
    let sine_q31_u64 = ((16 * product_q31_u64) << 31) / denominator_q31_u64;

    let sample_i64 = (sine_q31_u64 as i64 * sign_i64) >> 16;
    clamp_i64_to_i16(sample_i64)
}

#[inline]
const fn scale_sample_with_linear(sample_i16: i16, linear_i32: i32) -> i16 {
    if linear_i32 == 0 {
        return 0;
    }
    // Use signed full-scale magnitude (32768) so i16::MIN is handled correctly.
    // Full-scale linear is 32767, so add one to map it to exact unity gain.
    let unity_scaled_linear_i64 = linear_i32 as i64 + 1;
    let scaled_i64 = (sample_i16 as i64 * unity_scaled_linear_i64) / I16_ABS_MAX_I64;
    clamp_i64_to_i16(scaled_i64)
}

#[inline]
const fn scale_linear(linear_i32: i32, volume: Volume) -> i32 {
    if volume.to_i16() == 0 || linear_i32 == 0 {
        return 0;
    }
    let unity_scaled_volume_i64 = volume.to_i16() as i64 + 1;
    ((linear_i32 as i64 * unity_scaled_volume_i64) / I16_ABS_MAX_I64) as i32
}

#[inline]
const fn scale_sample(sample_i16: i16, volume: Volume) -> i16 {
    scale_sample_with_linear(sample_i16, volume.to_i16() as i32)
}

#[inline]
const fn clamp_i64_to_i16(value_i64: i64) -> i16 {
    if value_i64 > i16::MAX as i64 {
        i16::MAX
    } else if value_i64 < i16::MIN as i64 {
        i16::MIN
    } else {
        value_i64 as i16
    }
}

/// End-of-sequence behavior for playback.
///
/// `AudioPlayer` supports looping or stopping at the end of a clip sequence.
pub enum AtEnd {
    /// Repeat the full clip sequence forever.
    Loop,
    /// Stop after one full clip sequence pass.
    Stop,
}

// todo0 hide?
/// Self-describing PCM clip reference view used by playback APIs.
///
/// `AudioClipRef` is unsized so clips with different lengths can share one
/// reference type (`&AudioClipRef`) in the same playback sequence.
#[repr(C)]
pub struct AudioClipRef<T: ?Sized = [i16]> {
    sample_rate_hz: u32,
    samples: T,
}

impl AudioClipRef {
    /// Clip sample rate in hertz.
    #[must_use]
    pub const fn sample_rate_hz(&self) -> u32 {
        self.sample_rate_hz
    }

    /// Clip samples as an i16 PCM slice.
    #[must_use]
    pub(crate) const fn samples(&self) -> &[i16] {
        &self.samples
    }

    /// Number of PCM samples in this clip.
    #[must_use]
    pub const fn sample_count(&self) -> usize {
        self.samples.len()
    }
}

//todo0 avoid all use of " PCM clip "
/// Sized, const-friendly PCM clip storage.
pub type AudioClip<const SAMPLE_COUNT: usize> = AudioClipRef<[i16; SAMPLE_COUNT]>;

impl<const SAMPLE_COUNT: usize> AudioClipRef<[i16; SAMPLE_COUNT]> {
    /// Creates a clip from sample rate and PCM samples.
    #[must_use]
    const fn new(sample_rate_hz: u32, samples: [i16; SAMPLE_COUNT]) -> Self {
        assert!(sample_rate_hz > 0, "sample_rate_hz must be > 0");
        Self {
            sample_rate_hz,
            samples,
        }
    }

    /// Clip sample rate in hertz.
    #[must_use]
    pub const fn sample_rate_hz(&self) -> u32 {
        self.sample_rate_hz
    }

    /// Number of PCM samples in this clip.
    #[must_use]
    pub const fn sample_count(&self) -> usize {
        SAMPLE_COUNT
    }

    /// Returns a new clip with linear sample gain applied.
    ///
    /// Gain multiplication uses i32 math and saturates to i16 sample bounds.
    /// Boosting gain can hard-clip peaks and introduce distortion.
    #[must_use]
    pub const fn with_gain(self, gain: Gain) -> Self {
        let mut scaled_samples = [0_i16; SAMPLE_COUNT];
        let mut sample_index = 0_usize;
        while sample_index < SAMPLE_COUNT {
            scaled_samples[sample_index] =
                scale_sample_with_linear(self.samples[sample_index], gain.linear());
            sample_index += 1;
        }
        Self::new(self.sample_rate_hz, scaled_samples)
    }

    /// Creates a silent clip at `sample_rate_hz`.
    #[must_use]
    pub const fn silence(sample_rate_hz: u32) -> Self {
        Self::new(sample_rate_hz, [0; SAMPLE_COUNT])
    }

    /// Creates a sine-wave clip at `sample_rate_hz`.
    #[must_use]
    pub const fn tone(sample_rate_hz: u32, frequency_hz: u32) -> Self {
        assert!(sample_rate_hz > 0, "sample_rate_hz must be > 0");
        let mut samples = [0_i16; SAMPLE_COUNT];
        let phase_step_u64 = ((frequency_hz as u64) << 32) / sample_rate_hz as u64;
        let phase_step_u32 = phase_step_u64 as u32;
        let mut phase_u32 = 0_u32;

        let mut sample_index = 0_usize;
        while sample_index < SAMPLE_COUNT {
            samples[sample_index] = sine_sample_from_phase(phase_u32);
            phase_u32 = phase_u32.wrapping_add(phase_step_u32);
            sample_index += 1;
        }

        Self::new(sample_rate_hz, samples)
    }

    /// Creates a clip from little-endian s16 PCM bytes.
    ///
    /// `AUDIO_SAMPLE_BYTES_LEN` must be exactly `SAMPLE_COUNT * 2`.
    #[must_use]
    pub const fn from_s16le_bytes<const AUDIO_SAMPLE_BYTES_LEN: usize>(
        sample_rate_hz: u32,
        audio_sample_s16le: &[u8; AUDIO_SAMPLE_BYTES_LEN],
    ) -> Self {
        assert!(
            AUDIO_SAMPLE_BYTES_LEN == SAMPLE_COUNT * 2,
            "audio byte length must equal sample_count * 2"
        );

        let mut samples = [0_i16; SAMPLE_COUNT];
        let mut sample_index = 0_usize;
        while sample_index < SAMPLE_COUNT {
            let byte_index = sample_index * 2;
            samples[sample_index] = i16::from_le_bytes([
                audio_sample_s16le[byte_index],
                audio_sample_s16le[byte_index + 1],
            ]);
            sample_index += 1;
        }

        Self::new(sample_rate_hz, samples)
    }
}

//todo0 hide?
/// Supported clip input types for [`AudioPlayer::play_iter`].
pub trait IntoAudioClipRef {
    /// Converts this clip input into a static audio clip reference.
    fn into_audio_clip(self) -> &'static AudioClipRef;
}

impl IntoAudioClipRef for &'static AudioClipRef {
    fn into_audio_clip(self) -> &'static AudioClipRef {
        self
    }
}

impl<const SAMPLE_COUNT: usize> IntoAudioClipRef for &'static AudioClip<SAMPLE_COUNT> {
    fn into_audio_clip(self) -> &'static AudioClipRef {
        self
    }
}

enum AudioCommand<const MAX_CLIPS: usize> {
    Play {
        audio_clips: Vec<&'static AudioClipRef, MAX_CLIPS>,
        at_end: AtEnd,
    },
    Stop,
}

//todo0 hide?
/// Static resources for [`AudioPlayer`].
pub struct AudioPlayerStatic<const MAX_CLIPS: usize> {
    command_signal: Signal<CriticalSectionRawMutex, AudioCommand<MAX_CLIPS>>,
    max_volume_linear: i32,
    runtime_volume_relative_linear: AtomicI32,
}

impl<const MAX_CLIPS: usize> AudioPlayerStatic<MAX_CLIPS> {
    /// Creates static resources for a player.
    #[must_use]
    pub const fn new_static() -> Self {
        Self::new_static_with_max_volume_and_initial_volume(Volume::MAX, Volume::MAX)
    }

    /// Creates static resources for a player with a runtime volume ceiling.
    #[must_use]
    pub const fn new_static_with_max_volume(max_volume: Volume) -> Self {
        Self::new_static_with_max_volume_and_initial_volume(max_volume, Volume::MAX)
    }

    /// Creates static resources for a player with a runtime volume ceiling
    /// and an initial runtime volume relative to that ceiling.
    #[must_use]
    pub const fn new_static_with_max_volume_and_initial_volume(
        max_volume: Volume,
        initial_volume: Volume,
    ) -> Self {
        Self {
            command_signal: Signal::new(),
            max_volume_linear: max_volume.to_i16() as i32,
            runtime_volume_relative_linear: AtomicI32::new(initial_volume.to_i16() as i32),
        }
    }

    fn signal(&self, audio_command: AudioCommand<MAX_CLIPS>) {
        self.command_signal.signal(audio_command);
    }

    async fn wait(&self) -> AudioCommand<MAX_CLIPS> {
        self.command_signal.wait().await
    }

    fn set_runtime_volume(&self, volume: Volume) {
        self.runtime_volume_relative_linear
            .store(volume.to_i16() as i32, Ordering::Relaxed);
    }

    fn runtime_volume(&self) -> Volume {
        Volume::from_i16(self.runtime_volume_relative_linear.load(Ordering::Relaxed) as i16)
    }

    fn effective_runtime_volume(&self) -> Volume {
        let runtime_volume_relative = self.runtime_volume();
        Volume::from_i16(scale_linear(self.max_volume_linear, runtime_volume_relative) as i16)
    }

    fn max_volume(&self) -> Volume {
        Volume::from_i16(self.max_volume_linear as i16)
    }
}

/// Plays static PCM clips with preemptive command handling in the background device task.
///
/// See the [`audio_player!`] macro for the normal construction pattern.
pub struct AudioPlayer<const MAX_CLIPS: usize> {
    audio_player_static: &'static AudioPlayerStatic<MAX_CLIPS>,
}

impl<const MAX_CLIPS: usize> AudioPlayer<MAX_CLIPS> {
    /// Creates static resources for a player.
    #[must_use]
    pub const fn new_static() -> AudioPlayerStatic<MAX_CLIPS> {
        AudioPlayerStatic::new_static()
    }

    /// Creates static resources for a player with a runtime volume ceiling.
    #[must_use]
    pub const fn new_static_with_max_volume(max_volume: Volume) -> AudioPlayerStatic<MAX_CLIPS> {
        AudioPlayerStatic::new_static_with_max_volume(max_volume)
    }

    /// Creates static resources for a player with a runtime volume ceiling
    /// and an initial runtime volume relative to that ceiling.
    #[must_use]
    pub const fn new_static_with_max_volume_and_initial_volume(
        max_volume: Volume,
        initial_volume: Volume,
    ) -> AudioPlayerStatic<MAX_CLIPS> {
        AudioPlayerStatic::new_static_with_max_volume_and_initial_volume(max_volume, initial_volume)
    }

    /// Creates a player handle. The device task must already be running.
    #[must_use]
    pub const fn new(audio_player_static: &'static AudioPlayerStatic<MAX_CLIPS>) -> Self {
        Self {
            audio_player_static,
        }
    }

    /// Starts playback of one or more static PCM clips.
    ///
    /// This array-based API supports concise mixed-length clip literals like
    /// `[&tone_a4, &silence_100ms, &tone_a4]`.
    ///
    /// The clips are copied into a fixed-capacity clip list defined by `MAX_CLIPS`.
    /// A newer call to [`Self::play`] interrupts current playback as soon as possible
    /// (at the next DMA chunk boundary).
    pub fn play<const CLIP_COUNT: usize>(
        &self,
        audio_clips: [&'static AudioClipRef; CLIP_COUNT],
        at_end: AtEnd,
    ) {
        self.play_iter(audio_clips, at_end);
    }

    /// Starts playback from a generic iterator of static clip-like values.
    pub fn play_iter<I>(&self, audio_clips: I, at_end: AtEnd)
    where
        I: IntoIterator,
        I::Item: IntoAudioClipRef,
    {
        assert!(MAX_CLIPS > 0, "play disabled: max_clips is 0");
        let mut audio_clip_sequence: Vec<&'static AudioClipRef, MAX_CLIPS> = Vec::new();
        for audio_clip in audio_clips {
            let audio_clip = audio_clip.into_audio_clip();
            assert!(
                audio_clip.sample_rate_hz() == SAMPLE_RATE_HZ,
                "clip sample rate ({}) must match player sample rate ({})",
                audio_clip.sample_rate_hz(),
                SAMPLE_RATE_HZ
            );
            assert!(
                audio_clip_sequence.push(audio_clip).is_ok(),
                "play sequence fits within max_clips"
            );
        }
        assert!(
            !audio_clip_sequence.is_empty(),
            "play requires at least one clip"
        );

        self.audio_player_static.signal(AudioCommand::Play {
            audio_clips: audio_clip_sequence,
            at_end,
        });
    }

    /// Stops current playback as soon as possible.
    ///
    /// If playback is active, it is interrupted at the next DMA chunk boundary.
    pub fn stop(&self) {
        self.audio_player_static.signal(AudioCommand::Stop);
    }

    /// Sets runtime playback volume relative to [`Self::max_volume`].
    ///
    /// - `Volume::percent(100)` plays at exactly `max_volume`.
    /// - `Volume::percent(50)` plays at half of `max_volume`.
    ///
    /// This relative scale composes multiplicatively with any per-clip gain
    /// pre-applied via [`AudioClip::with_gain`].
    pub fn set_volume(&self, volume: Volume) {
        self.audio_player_static.set_runtime_volume(volume);
    }

    /// Returns the current runtime playback volume relative to [`Self::max_volume`].
    #[must_use]
    pub fn volume(&self) -> Volume {
        self.audio_player_static.runtime_volume()
    }

    /// Returns the configured runtime volume ceiling.
    #[must_use]
    pub fn max_volume(&self) -> Volume {
        self.audio_player_static.max_volume()
    }
}

// todo0 hide?
// todo0 does this really need to be different that other device abstraction traits?
/// Trait mapping a PIO peripheral to its interrupt binding.
pub trait AudioPlayerPio: Instance {
    /// Interrupt binding type for this PIO resource.
    type Irqs: embassy_rp::interrupt::typelevel::Binding<
            <Self as Instance>::Interrupt,
            embassy_rp::pio::InterruptHandler<Self>,
        >;

    /// Returns interrupt bindings for this PIO resource.
    fn irqs() -> Self::Irqs;
}

impl AudioPlayerPio for embassy_rp::peripherals::PIO0 {
    type Irqs = crate::pio_irqs::Pio0Irqs;

    fn irqs() -> Self::Irqs {
        crate::pio_irqs::Pio0Irqs
    }
}

impl AudioPlayerPio for embassy_rp::peripherals::PIO1 {
    type Irqs = crate::pio_irqs::Pio1Irqs;

    fn irqs() -> Self::Irqs {
        crate::pio_irqs::Pio1Irqs
    }
}

#[cfg(feature = "pico2")]
impl AudioPlayerPio for embassy_rp::peripherals::PIO2 {
    type Irqs = crate::pio_irqs::Pio2Irqs;

    fn irqs() -> Self::Irqs {
        crate::pio_irqs::Pio2Irqs
    }
}

// Called by macro-generated code in downstream crates; must be public.
#[doc(hidden)]
pub async fn device_loop<
    const MAX_CLIPS: usize,
    PIO: AudioPlayerPio,
    DMA: Channel,
    DinPin: Pin + PioPin,
    BclkPin: Pin + PioPin,
    LrcPin: Pin + PioPin,
>(
    audio_player_static: &'static AudioPlayerStatic<MAX_CLIPS>,
    pio: Peri<'static, PIO>,
    dma: Peri<'static, DMA>,
    din_pin: Peri<'static, DinPin>,
    bclk_pin: Peri<'static, BclkPin>,
    lrc_pin: Peri<'static, LrcPin>,
) -> ! {
    let mut pio = Pio::new(pio, PIO::irqs());
    let pio_i2s_out_program = PioI2sOutProgram::new(&mut pio.common);
    let mut pio_i2s_out = PioI2sOut::new(
        &mut pio.common,
        pio.sm0,
        dma,
        din_pin,
        bclk_pin,
        lrc_pin,
        SAMPLE_RATE_HZ,
        BIT_DEPTH_BITS,
        &pio_i2s_out_program,
    );

    let _pio_i2s_out_program = pio_i2s_out_program;
    let mut sample_buffer = [0_u32; SAMPLE_BUFFER_LEN];

    loop {
        let mut audio_command = audio_player_static.wait().await;

        loop {
            match audio_command {
                AudioCommand::Play {
                    audio_clips,
                    at_end,
                } => {
                    let next_audio_command = match at_end {
                        AtEnd::Loop => loop {
                            if let Some(next_audio_command) = play_clip_sequence_once(
                                &mut pio_i2s_out,
                                &audio_clips,
                                &mut sample_buffer,
                                audio_player_static,
                            )
                            .await
                            {
                                break Some(next_audio_command);
                            }
                        },
                        AtEnd::Stop => {
                            play_clip_sequence_once(
                                &mut pio_i2s_out,
                                &audio_clips,
                                &mut sample_buffer,
                                audio_player_static,
                            )
                            .await
                        }
                    };

                    if let Some(next_audio_command) = next_audio_command {
                        audio_command = next_audio_command;
                        continue;
                    }
                }
                AudioCommand::Stop => {}
            }

            break;
        }
    }
}

async fn play_clip_sequence_once<PIO: Instance, const MAX_CLIPS: usize>(
    pio_i2s_out: &mut PioI2sOut<'static, PIO, 0>,
    audio_clips: &[&'static AudioClipRef],
    sample_buffer: &mut [u32; SAMPLE_BUFFER_LEN],
    audio_player_static: &'static AudioPlayerStatic<MAX_CLIPS>,
) -> Option<AudioCommand<MAX_CLIPS>> {
    for audio_clip in audio_clips {
        if let ControlFlow::Break(next_audio_command) =
            play_full_clip_once(pio_i2s_out, audio_clip, sample_buffer, audio_player_static).await
        {
            return Some(next_audio_command);
        }
    }
    None
}

async fn play_full_clip_once<PIO: Instance, const MAX_CLIPS: usize>(
    pio_i2s_out: &mut PioI2sOut<'static, PIO, 0>,
    audio_clip: &AudioClipRef,
    sample_buffer: &mut [u32; SAMPLE_BUFFER_LEN],
    audio_player_static: &'static AudioPlayerStatic<MAX_CLIPS>,
) -> ControlFlow<AudioCommand<MAX_CLIPS>, ()> {
    for audio_sample_chunk in audio_clip.samples().chunks(SAMPLE_BUFFER_LEN) {
        let runtime_volume = audio_player_static.effective_runtime_volume();
        for (sample_buffer_slot, sample_value_ref) in
            sample_buffer.iter_mut().zip(audio_sample_chunk.iter())
        {
            let sample_value = *sample_value_ref;
            let scaled_sample_value = scale_sample(sample_value, runtime_volume);
            *sample_buffer_slot = stereo_sample(scaled_sample_value);
        }

        sample_buffer[audio_sample_chunk.len()..].fill(stereo_sample(0));
        pio_i2s_out.write(sample_buffer).await;

        if let Some(next_audio_command) = audio_player_static.command_signal.try_take() {
            return ControlFlow::Break(next_audio_command);
        }
    }

    ControlFlow::Continue(())
}

#[inline]
const fn stereo_sample(sample: i16) -> u32 {
    let sample_bits = sample as u16 as u32;
    (sample_bits << 16) | sample_bits
}

pub use paste;

//todo0 make better example
/// Expands to an [`AudioClip`] type sized from a player type and milliseconds.
///
/// Example: `samples_ms!{AudioPlayer8, 500}`.
#[doc(hidden)]
#[macro_export]
macro_rules! samples_ms {
    ($player:ident, $duration_ms:expr) => {
        $crate::audio_player::AudioClip<{ $player::samples_ms($duration_ms) }>
    };
}

/// Macro to generate an audio player struct type (includes syntax details). See
/// [`AudioPlayerGenerated`](crate::audio_player::audio_player_generated::AudioPlayerGenerated)
/// for a sample of a generated type.
///
/// **See the [audio_player module documentation](mod@crate::audio_player) for
/// usage examples.**
///
/// **Required fields:**
///
/// - `din_pin` - GPIO pin carrying I2S data (`DIN`)
/// - `bclk_pin` - GPIO pin carrying I2S bit clock (`BCLK`)
/// - `lrc_pin` - GPIO pin carrying I2S word-select / LR clock (`LRC`)
///
/// **Optional fields:**
///
/// - `pio` - PIO resource (default: `PIO1`)
/// - `dma` - DMA channel (default: `DMA_CH0`)
/// - `max_clips` - Maximum clips per queued play request (default: `16`)
/// - `max_volume` - Runtime volume ceiling (default: [`Volume::MAX`])
/// - `initial_volume` - Initial runtime volume relative to `max_volume`
///   (default: [`Volume::MAX`])
///
/// The generated type contains static resources and spawns its background device
/// task from `new(...)`.
#[doc(hidden)]
#[macro_export]
macro_rules! audio_player {
    ($($tt:tt)*) => { $crate::__audio_player_impl! { $($tt)* } };
}

/// Internal implementation macro for [`audio_player!`].
#[doc(hidden)]
#[macro_export]
macro_rules! __audio_player_impl {
    (
        $name:ident {
            $($fields:tt)*
        }
    ) => {
        $crate::__audio_player_impl! {
            @__fill_defaults
            vis: pub,
            name: $name,
            din_pin: _UNSET_,
            bclk_pin: _UNSET_,
            lrc_pin: _UNSET_,
            pio: PIO1,
            dma: DMA_CH0,
            max_clips: 16,
            max_volume: $crate::audio_player::Volume::MAX,
            initial_volume: $crate::audio_player::Volume::MAX,
            fields: [ $($fields)* ]
        }
    };

    (
        $vis:vis $name:ident {
            $($fields:tt)*
        }
    ) => {
        $crate::__audio_player_impl! {
            @__fill_defaults
            vis: $vis,
            name: $name,
            din_pin: _UNSET_,
            bclk_pin: _UNSET_,
            lrc_pin: _UNSET_,
            pio: PIO1,
            dma: DMA_CH0,
            max_clips: 16,
            max_volume: $crate::audio_player::Volume::MAX,
            initial_volume: $crate::audio_player::Volume::MAX,
            fields: [ $($fields)* ]
        }
    };

    (@__fill_defaults
        vis: $vis:vis,
        name: $name:ident,
        din_pin: $din_pin:tt,
        bclk_pin: $bclk_pin:tt,
        lrc_pin: $lrc_pin:tt,
        pio: $pio:ident,
        dma: $dma:ident,
        max_clips: $max_clips:expr,
        max_volume: $max_volume:expr,
        initial_volume: $initial_volume:expr,
        fields: [ din_pin: $din_pin_value:ident $(, $($rest:tt)* )? ]
    ) => {
        $crate::__audio_player_impl! {
            @__fill_defaults
            vis: $vis,
            name: $name,
            din_pin: $din_pin_value,
            bclk_pin: $bclk_pin,
            lrc_pin: $lrc_pin,
            pio: $pio,
            dma: $dma,
            max_clips: $max_clips,
            max_volume: $max_volume,
            initial_volume: $initial_volume,
            fields: [ $($($rest)*)? ]
        }
    };

    (@__fill_defaults
        vis: $vis:vis,
        name: $name:ident,
        din_pin: $din_pin:tt,
        bclk_pin: $bclk_pin:tt,
        lrc_pin: $lrc_pin:tt,
        pio: $pio:ident,
        dma: $dma:ident,
        max_clips: $max_clips:expr,
        max_volume: $max_volume:expr,
        initial_volume: $initial_volume:expr,
        fields: [ bclk_pin: $bclk_pin_value:ident $(, $($rest:tt)* )? ]
    ) => {
        $crate::__audio_player_impl! {
            @__fill_defaults
            vis: $vis,
            name: $name,
            din_pin: $din_pin,
            bclk_pin: $bclk_pin_value,
            lrc_pin: $lrc_pin,
            pio: $pio,
            dma: $dma,
            max_clips: $max_clips,
            max_volume: $max_volume,
            initial_volume: $initial_volume,
            fields: [ $($($rest)*)? ]
        }
    };

    (@__fill_defaults
        vis: $vis:vis,
        name: $name:ident,
        din_pin: $din_pin:tt,
        bclk_pin: $bclk_pin:tt,
        lrc_pin: $lrc_pin:tt,
        pio: $pio:ident,
        dma: $dma:ident,
        max_clips: $max_clips:expr,
        max_volume: $max_volume:expr,
        initial_volume: $initial_volume:expr,
        fields: [ lrc_pin: $lrc_pin_value:ident $(, $($rest:tt)* )? ]
    ) => {
        $crate::__audio_player_impl! {
            @__fill_defaults
            vis: $vis,
            name: $name,
            din_pin: $din_pin,
            bclk_pin: $bclk_pin,
            lrc_pin: $lrc_pin_value,
            pio: $pio,
            dma: $dma,
            max_clips: $max_clips,
            max_volume: $max_volume,
            initial_volume: $initial_volume,
            fields: [ $($($rest)*)? ]
        }
    };

    (@__fill_defaults
        vis: $vis:vis,
        name: $name:ident,
        din_pin: $din_pin:tt,
        bclk_pin: $bclk_pin:tt,
        lrc_pin: $lrc_pin:tt,
        pio: $pio:ident,
        dma: $dma:ident,
        max_clips: $max_clips:expr,
        max_volume: $max_volume:expr,
        initial_volume: $initial_volume:expr,
        fields: [ pio: $pio_value:ident $(, $($rest:tt)* )? ]
    ) => {
        $crate::__audio_player_impl! {
            @__fill_defaults
            vis: $vis,
            name: $name,
            din_pin: $din_pin,
            bclk_pin: $bclk_pin,
            lrc_pin: $lrc_pin,
            pio: $pio_value,
            dma: $dma,
            max_clips: $max_clips,
            max_volume: $max_volume,
            initial_volume: $initial_volume,
            fields: [ $($($rest)*)? ]
        }
    };

    (@__fill_defaults
        vis: $vis:vis,
        name: $name:ident,
        din_pin: $din_pin:tt,
        bclk_pin: $bclk_pin:tt,
        lrc_pin: $lrc_pin:tt,
        pio: $pio:ident,
        dma: $dma:ident,
        max_clips: $max_clips:expr,
        max_volume: $max_volume:expr,
        initial_volume: $initial_volume:expr,
        fields: [ dma: $dma_value:ident $(, $($rest:tt)* )? ]
    ) => {
        $crate::__audio_player_impl! {
            @__fill_defaults
            vis: $vis,
            name: $name,
            din_pin: $din_pin,
            bclk_pin: $bclk_pin,
            lrc_pin: $lrc_pin,
            pio: $pio,
            dma: $dma_value,
            max_clips: $max_clips,
            max_volume: $max_volume,
            initial_volume: $initial_volume,
            fields: [ $($($rest)*)? ]
        }
    };

    (@__fill_defaults
        vis: $vis:vis,
        name: $name:ident,
        din_pin: $din_pin:tt,
        bclk_pin: $bclk_pin:tt,
        lrc_pin: $lrc_pin:tt,
        pio: $pio:ident,
        dma: $dma:ident,
        max_clips: $max_clips:expr,
        max_volume: $max_volume:expr,
        initial_volume: $initial_volume:expr,
        fields: [ max_clips: $max_clips_value:expr $(, $($rest:tt)* )? ]
    ) => {
        $crate::__audio_player_impl! {
            @__fill_defaults
            vis: $vis,
            name: $name,
            din_pin: $din_pin,
            bclk_pin: $bclk_pin,
            lrc_pin: $lrc_pin,
            pio: $pio,
            dma: $dma,
            max_clips: $max_clips_value,
            max_volume: $max_volume,
            initial_volume: $initial_volume,
            fields: [ $($($rest)*)? ]
        }
    };

    (@__fill_defaults
        vis: $vis:vis,
        name: $name:ident,
        din_pin: $din_pin:tt,
        bclk_pin: $bclk_pin:tt,
        lrc_pin: $lrc_pin:tt,
        pio: $pio:ident,
        dma: $dma:ident,
        max_clips: $max_clips:expr,
        max_volume: $max_volume:expr,
        initial_volume: $initial_volume:expr,
        fields: [ max_volume: $max_volume_value:expr $(, $($rest:tt)* )? ]
    ) => {
        $crate::__audio_player_impl! {
            @__fill_defaults
            vis: $vis,
            name: $name,
            din_pin: $din_pin,
            bclk_pin: $bclk_pin,
            lrc_pin: $lrc_pin,
            pio: $pio,
            dma: $dma,
            max_clips: $max_clips,
            max_volume: $max_volume_value,
            initial_volume: $initial_volume,
            fields: [ $($($rest)*)? ]
        }
    };

    (@__fill_defaults
        vis: $vis:vis,
        name: $name:ident,
        din_pin: $din_pin:tt,
        bclk_pin: $bclk_pin:tt,
        lrc_pin: $lrc_pin:tt,
        pio: $pio:ident,
        dma: $dma:ident,
        max_clips: $max_clips:expr,
        max_volume: $max_volume:expr,
        initial_volume: $initial_volume:expr,
        fields: [ initial_volume: $initial_volume_value:expr $(, $($rest:tt)* )? ]
    ) => {
        $crate::__audio_player_impl! {
            @__fill_defaults
            vis: $vis,
            name: $name,
            din_pin: $din_pin,
            bclk_pin: $bclk_pin,
            lrc_pin: $lrc_pin,
            pio: $pio,
            dma: $dma,
            max_clips: $max_clips,
            max_volume: $max_volume,
            initial_volume: $initial_volume_value,
            fields: [ $($($rest)*)? ]
        }
    };

    (@__fill_defaults
        vis: $vis:vis,
        name: $name:ident,
        din_pin: $din_pin:tt,
        bclk_pin: $bclk_pin:tt,
        lrc_pin: $lrc_pin:tt,
        pio: $pio:ident,
        dma: $dma:ident,
        max_clips: $max_clips:expr,
        max_volume: $max_volume:expr,
        initial_volume: $initial_volume:expr,
        fields: [ volume: $volume_value:expr $(, $($rest:tt)* )? ]
    ) => {
        compile_error!("audio_player! field `volume` was renamed to `max_volume`");
    };

    (@__fill_defaults
        vis: $vis:vis,
        name: $name:ident,
        din_pin: _UNSET_,
        bclk_pin: $bclk_pin:tt,
        lrc_pin: $lrc_pin:tt,
        pio: $pio:ident,
        dma: $dma:ident,
        max_clips: $max_clips:expr,
        max_volume: $max_volume:expr,
        initial_volume: $initial_volume:expr,
        fields: [ ]
    ) => {
        compile_error!("audio_player! requires din_pin");
    };

    (@__fill_defaults
        vis: $vis:vis,
        name: $name:ident,
        din_pin: $din_pin:ident,
        bclk_pin: _UNSET_,
        lrc_pin: $lrc_pin:tt,
        pio: $pio:ident,
        dma: $dma:ident,
        max_clips: $max_clips:expr,
        max_volume: $max_volume:expr,
        initial_volume: $initial_volume:expr,
        fields: [ ]
    ) => {
        compile_error!("audio_player! requires bclk_pin");
    };

    (@__fill_defaults
        vis: $vis:vis,
        name: $name:ident,
        din_pin: $din_pin:ident,
        bclk_pin: $bclk_pin:ident,
        lrc_pin: _UNSET_,
        pio: $pio:ident,
        dma: $dma:ident,
        max_clips: $max_clips:expr,
        max_volume: $max_volume:expr,
        initial_volume: $initial_volume:expr,
        fields: [ ]
    ) => {
        compile_error!("audio_player! requires lrc_pin");
    };

    (@__fill_defaults
        vis: $vis:vis,
        name: $name:ident,
        din_pin: $din_pin:ident,
        bclk_pin: $bclk_pin:ident,
        lrc_pin: $lrc_pin:ident,
        pio: $pio:ident,
        dma: $dma:ident,
        max_clips: $max_clips:expr,
        max_volume: $max_volume:expr,
        initial_volume: $initial_volume:expr,
        fields: [ ]
    ) => {
        $crate::audio_player::paste::paste! {
            static [<$name:upper _AUDIO_PLAYER_STATIC>]: $crate::audio_player::AudioPlayerStatic<$max_clips> =
                $crate::audio_player::AudioPlayer::<$max_clips>::new_static_with_max_volume_and_initial_volume(
                    $max_volume,
                    $initial_volume,
                );
            static [<$name:upper _AUDIO_PLAYER_CELL>]: ::static_cell::StaticCell<$name> =
                ::static_cell::StaticCell::new();

            #[doc = concat!(
                "Audio player generated by [`audio_player!`](macro@crate::audio_player).\n\n",
                "See the [audio_player module documentation](mod@crate::audio_player) for usage and examples."
            )]
            $vis struct $name {
                player: $crate::audio_player::AudioPlayer<$max_clips>,
            }

            impl $name {
                /// Sample rate used for PCM playback by this generated player type.
                pub const SAMPLE_RATE_HZ: u32 = $crate::audio_player::SAMPLE_RATE_HZ;
                /// Initial runtime volume relative to [`Self::MAX_VOLUME`].
                pub const INITIAL_VOLUME: $crate::audio_player::Volume = $initial_volume;
                /// Runtime volume ceiling for this generated player type.
                pub const MAX_VOLUME: $crate::audio_player::Volume = $max_volume;

                /// Returns how many samples are needed for a duration in milliseconds
                /// at this player's sample rate.
                #[must_use]
                pub const fn samples_for_duration_ms(duration_ms: u32) -> usize {
                    $crate::audio_player::samples_for_duration_ms(duration_ms, Self::SAMPLE_RATE_HZ)
                }

                /// Shorthand alias for [`Self::samples_for_duration_ms`].
                #[must_use]
                pub const fn samples_ms(duration_ms: u32) -> usize {
                    Self::samples_for_duration_ms(duration_ms)
                }

                /// Creates a silent clip at this player's sample rate.
                #[must_use]
                pub const fn silence<const SAMPLE_COUNT: usize>(
                ) -> $crate::audio_player::AudioClip<SAMPLE_COUNT> {
                    $crate::audio_player::AudioClip::silence(Self::SAMPLE_RATE_HZ)
                }

                /// Creates a sine-wave clip at this player's sample rate.
                #[must_use]
                pub const fn tone<const SAMPLE_COUNT: usize>(
                    frequency_hz: u32,
                ) -> $crate::audio_player::AudioClip<SAMPLE_COUNT> {
                    $crate::audio_player::AudioClip::tone(Self::SAMPLE_RATE_HZ, frequency_hz)
                }

                // todo0 hide?
                /// Creates a clip from little-endian s16 PCM bytes at this player's sample rate.
                #[must_use]
                pub const fn clip_from_s16le_bytes<const SAMPLE_COUNT: usize, const AUDIO_SAMPLE_BYTES_LEN: usize>(
                    audio_sample_s16le: &[u8; AUDIO_SAMPLE_BYTES_LEN],
                ) -> $crate::audio_player::AudioClip<SAMPLE_COUNT> {
                    $crate::audio_player::AudioClip::from_s16le_bytes(
                        Self::SAMPLE_RATE_HZ,
                        audio_sample_s16le,
                    )
                }

                /// Creates and spawns the generated audio player instance.
                ///
                /// See the [audio_player module documentation](mod@crate::audio_player)
                /// for example usage.
                pub fn new(
                    din_pin: impl Into<::embassy_rp::Peri<'static, ::embassy_rp::peripherals::$din_pin>>,
                    bclk_pin: impl Into<::embassy_rp::Peri<'static, ::embassy_rp::peripherals::$bclk_pin>>,
                    lrc_pin: impl Into<::embassy_rp::Peri<'static, ::embassy_rp::peripherals::$lrc_pin>>,
                    pio: impl Into<::embassy_rp::Peri<'static, ::embassy_rp::peripherals::$pio>>,
                    dma: impl Into<::embassy_rp::Peri<'static, ::embassy_rp::peripherals::$dma>>,
                    spawner: ::embassy_executor::Spawner,
                ) -> $crate::Result<&'static Self> {
                    let token = [<$name:snake _audio_player_task>](
                        &[<$name:upper _AUDIO_PLAYER_STATIC>],
                        pio.into(),
                        dma.into(),
                        din_pin.into(),
                        bclk_pin.into(),
                        lrc_pin.into(),
                    );
                    spawner.spawn(token)?;
                    let player = $crate::audio_player::AudioPlayer::new(&[<$name:upper _AUDIO_PLAYER_STATIC>]);
                    Ok([<$name:upper _AUDIO_PLAYER_CELL>].init(Self { player }))
                }
            }

            impl ::core::ops::Deref for $name {
                type Target = $crate::audio_player::AudioPlayer<$max_clips>;

                fn deref(&self) -> &Self::Target {
                    &self.player
                }
            }

            #[::embassy_executor::task]
            async fn [<$name:snake _audio_player_task>](
                audio_player_static: &'static $crate::audio_player::AudioPlayerStatic<$max_clips>,
                pio: ::embassy_rp::Peri<'static, ::embassy_rp::peripherals::$pio>,
                dma: ::embassy_rp::Peri<'static, ::embassy_rp::peripherals::$dma>,
                din_pin: ::embassy_rp::Peri<'static, ::embassy_rp::peripherals::$din_pin>,
                bclk_pin: ::embassy_rp::Peri<'static, ::embassy_rp::peripherals::$bclk_pin>,
                lrc_pin: ::embassy_rp::Peri<'static, ::embassy_rp::peripherals::$lrc_pin>,
            ) -> ! {
                $crate::audio_player::device_loop::<
                    $max_clips,
                    ::embassy_rp::peripherals::$pio,
                    ::embassy_rp::peripherals::$dma,
                    ::embassy_rp::peripherals::$din_pin,
                    ::embassy_rp::peripherals::$bclk_pin,
                    ::embassy_rp::peripherals::$lrc_pin,
                >(audio_player_static, pio, dma, din_pin, bclk_pin, lrc_pin).await
            }
        }
    };
}

#[doc(inline)]
pub use audio_player;
#[doc(inline)]
pub use samples_ms;
